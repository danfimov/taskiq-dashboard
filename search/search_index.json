{"config":{"lang":["ru"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Broker-agnostic admin dashboard for Taskiq.</p> <p>Live demo of UI: https://taskiq-dashboard.danfimov.com/</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>taskiq-dashboard</code> package, run the following command:</p> pippoetryuv <pre><code>pip install taskiq-dashboard\n</code></pre> <pre><code>poetry add taskiq-dashboard\n</code></pre> <pre><code>uv pip install taskiq-dashboard\n</code></pre> <p>To pull the Docker image with <code>taskiq-dashboard</code> application , run the following command:</p> <pre><code>docker pull ghcr.io/danfimov/taskiq-dashboard:latest\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#run-with-code","title":"Run with code","text":"<ol> <li> <p>Import and connect middleware to your Taskiq broker:</p> <pre><code>from taskiq.middlewares.taskiq_admin_middleware import TaskiqAdminMiddleware\n\nbroker = (\n    RedisStreamBroker(\n        url=redis_url,\n        queue_name=\"my_lovely_queue\",\n    )\n    .with_result_backend(result_backend)\n    .with_middlewares(\n        TaskiqAdminMiddleware(\n            url=\"http://localhost:8000\", # the url to your taskiq-dashboard instance\n            api_token=\"supersecret\",  # secret for accessing the dashboard API\n            taskiq_broker_name=\"my_worker\",  # it will be worker name in the dashboard\n        )\n    )\n)\n</code></pre> </li> <li> <p>Run taskiq-dashboard with the following code:</p> postgressqlite <pre><code>from taskiq_dashboard import TaskiqDashboard\nfrom your_project.broker import broker  # your Taskiq broker instance\n\ndef run_admin_panel() -&gt; None:\n    app = TaskiqDashboard(\n        api_token='supersecret', # the same secret as in middleware\n        storage_type='postgres',\n        database_dsn=\"postgresql://taskiq-dashboard:look_in_vault@postgres:5432/taskiq-dashboard\",\n        broker=broker,  # pass your broker instance here to enable additional features\n        host='0.0.0.0',\n        port=8000,\n    )\n    app.run()\n\nif __name__ == '__main__':\n    run_admin_panel()\n</code></pre> <pre><code>from taskiq_dashboard import TaskiqDashboard\nfrom your_project.broker import broker  # your Taskiq broker instance\n\ndef run_admin_panel() -&gt; None:\n    app = TaskiqDashboard(\n        api_token='supersecret', # the same secret as in middleware\n        storage_type='sqlite',\n        database_dsn=\"sqlite+aiosqlite:///taskiq_dashboard.db\",\n        broker=broker,  # pass your broker instance here to enable additional features\n        host='0.0.0.0',\n        port=8000,\n    )\n    app.run()\n\nif __name__ == '__main__':\n    run_admin_panel()\n</code></pre> </li> </ol> <p>You can also pass <code>broker</code> or <code>scheduler</code> instances directly to the <code>TaskiqDashboard</code> constructor and get additional features like actions with tasks or schedule configuration. Read more about it in the tutorial section.</p>"},{"location":"#run-with-docker-compose","title":"Run with docker compose","text":"postgressqlite <pre><code>services:\n  postgres:\n    image: postgres:18\n    environment:\n      POSTGRES_USER: taskiq-dashboard\n      POSTGRES_PASSWORD: look_in_vault\n      POSTGRES_DB: taskiq-dashboard\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\n  dashboard:\n    image: ghcr.io/danfimov/taskiq-dashboard:latest\n    depends_on:\n      - postgres\n    environment:\n      TASKIQ_DASHBOARD__STORAGE_TYPE: postgres\n      TASKIQ_DASHBOARD__POSTGRES__HOST: postgres\n      TASKIQ_DASHBOARD__API__TOKEN: supersecret\n    ports:\n      - \"8000:8000\"\n\nvolumes:\n  postgres_data:\n</code></pre> <pre><code>services:\n  dashboard:\n    image: ghcr.io/danfimov/taskiq-dashboard:latest\n    environment:\n      TASKIQ_DASHBOARD__STORAGE_TYPE: postgres\n      TASKIQ_DASHBOARD__SQLITE__DSN: sqlite+aiosqlite:///taskiq_dashboard.db\n      TASKIQ_DASHBOARD__API__TOKEN: supersecret\n    volumes:\n      - taskiq_dashboard_sqlite:/app/taskiq-dashboard.db\n    ports:\n      - \"8000:8000\"\n\nvolumes:\n  taskiq_dashboard_sqlite:\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>Taskiq-dashboard can run with PostgreSQL or SQLite as storage for information about tasks.</p> <p>You can configure application using environment variables (if you run it inside docker container) or by passing parameters directly to the <code>TaskiqDashboard</code> constructor.</p> <p>For example you can pass uvicorn parameters like <code>host</code>, <code>port</code>, <code>log_level</code> directly to the constructor:</p> postgressqlite <pre><code>app = TaskiqDashboard(\n    api_token='supersecret',\n    storage_type='postgres',\n    database_dsn=\"postgresql://taskiq-dashboard:look_in_vault@postgres:5432/taskiq-dashboard\",\n    # all this keywords will be passed to uvicorn\n    host='localhost',\n    port=8000,\n    log_level='info',\n    access_log=False,\n)\n</code></pre> <pre><code>app = TaskiqDashboard(\n    api_token='supersecret',\n    storage_type='sqlite',\n    database_dsn=\"sqlite+aiosqlite:///taskiq_dashboard.db\",\n    # all this keywords will be passed to uvicorn\n    host='localhost',\n    port=8000,\n    log_level='info',\n    access_log=False,\n)\n</code></pre> <p>You can also configure the database connection or API parameters using environment variables:</p> postgressqlite <pre><code>TASKIQ_DASHBOARD__POSTGRES__DRIVER=postgresql+asyncpg\nTASKIQ_DASHBOARD__POSTGRES__HOST=localhost\nTASKIQ_DASHBOARD__POSTGRES__PORT=5432\nTASKIQ_DASHBOARD__POSTGRES__USER=taskiq-dashboard\nTASKIQ_DASHBOARD__POSTGRES__PASSWORD=look_in_vault\nTASKIQ_DASHBOARD__POSTGRES__DATABASE=taskiq-dashboard\nTASKIQ_DASHBOARD__POSTGRES__MIN_POOL_SIZE=1\nTASKIQ_DASHBOARD__POSTGRES__MAX_POOL_SIZE=5\n# or just use DSN: TASKIQ_DASHBOARD__POSTGRES__DSN=postgresql+asyncpg://taskiq-dashboard:look_in_vault@localhost:5432/taskiq-dashboard\n\nTASKIQ_DASHBOARD__API__HOST=localhost\nTASKIQ_DASHBOARD__API__PORT=8000\nTASKIQ_DASHBOARD__API__TOKEN=supersecret\n</code></pre> <pre><code>TASKIQ_DASHBOARD__SQLITE__DRIVER=sqlite+aiosqlite\nTASKIQ_DASHBOARD__SQLITE__FILE_PATH=taskiq-dashboard.db\n# or just use DSN: TASKIQ_DASHBOARD__SQLITE__DSN=sqlite+aiosqlite:///taskiq_dashboard.db\n\nTASKIQ_DASHBOARD__API__HOST=localhost\nTASKIQ_DASHBOARD__API__PORT=8000\nTASKIQ_DASHBOARD__API__TOKEN=supersecret\n</code></pre>"},{"location":"#dashboard-information","title":"Dashboard information","text":""},{"location":"#task-statuses","title":"Task statuses","text":"<p>Let's assume we have a task <code>do_smth</code>, there are all states it can embrace:</p> <ul> <li><code>queued</code> - the task has been sent to the queue without an error</li> <li><code>running</code> - the task is grabbed by a worker and is being processed</li> <li><code>success</code> - the task is fully processed without any errors</li> <li><code>failure</code> - an error occurred during the task processing</li> </ul>"},{"location":"contributing/","title":"Contributing and Development","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Add tests for new functionality</li> <li>Ensure all tests pass</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#setting-up-local-development-environment","title":"Setting up local development environment","text":"<p>To run the application locally for development, follow these steps:</p> <ol> <li> <p>Clone the repository:</p> <pre><code>git clone\nhttps://github.com/danfimov/taskiq-dashboard.git\ncd taskiq-dashboard\n</code></pre> </li> <li> <p>Create a virtual environment, activate it, install dependencies and pre-commit hooks:</p> <pre><code>make init\n</code></pre> </li> <li> <p>Start a local PostgreSQL instance using Docker:</p> <pre><code>make run_infra\n</code></pre> </li> <li> <p>Run tailwindcss in watch mode to compile CSS:</p> <pre><code>pnpm run dev\n</code></pre> </li> <li> <p>Start the dashboard application:</p> <pre><code>make run\n</code></pre> </li> </ol> <p>You can see other useful commands by running <code>make help</code>.</p>"},{"location":"reference/","title":"API","text":""},{"location":"reference/#taskiq_dashboard","title":"taskiq_dashboard","text":""},{"location":"reference/#taskiq_dashboard.TaskiqDashboard","title":"TaskiqDashboard","text":"<pre><code>TaskiqDashboard(\n    api_token,\n    storage_type='sqlite',\n    database_dsn='sqlite+aiosqlite:///taskiq_dashboard.db',\n    broker=None,\n    scheduler=None,\n    **uvicorn_kwargs,\n)\n</code></pre> <p>Initialize Taskiq Dashboard application.</p> <p>Parameters:</p> <ul> <li> <code>api_token</code>               (<code>str</code>)           \u2013            <p>Access token for securing the dashboard API.</p> </li> <li> <code>storage_type</code>               (<code>Literal['sqlite', 'postgres']</code>, default:                   <code>'sqlite'</code> )           \u2013            <p>Type of the storage backend ('sqlite' or 'postgres').</p> </li> <li> <code>database_dsn</code>               (<code>str</code>, default:                   <code>'sqlite+aiosqlite:///taskiq_dashboard.db'</code> )           \u2013            <p>URL for the database.</p> </li> <li> <code>broker</code>               (<code>AsyncBroker | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional Taskiq broker instance to integrate with the dashboard.</p> </li> <li> <code>scheduler</code>               (<code>TaskiqScheduler | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional Taskiq scheduler instance to integrate with the dashboard.</p> </li> <li> <code>uvicorn_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to uvicorn.</p> </li> </ul> Source code in <code>taskiq_dashboard/interface/application.py</code> <pre><code>def __init__(\n    self,\n    api_token: str,\n    storage_type: tp.Literal['sqlite', 'postgres'] = 'sqlite',\n    database_dsn: str = 'sqlite+aiosqlite:///taskiq_dashboard.db',\n    broker: AsyncBroker | None = None,\n    scheduler: TaskiqScheduler | None = None,\n    **uvicorn_kwargs: tp.Any,\n) -&gt; None:\n    \"\"\"Initialize Taskiq Dashboard application.\n\n    Args:\n        api_token: Access token for securing the dashboard API.\n        storage_type: Type of the storage backend ('sqlite' or 'postgres').\n        database_dsn: URL for the database.\n        broker: Optional Taskiq broker instance to integrate with the dashboard.\n        scheduler: Optional Taskiq scheduler instance to integrate with the dashboard.\n        uvicorn_kwargs: Additional keyword arguments to pass to uvicorn.\n    \"\"\"\n    self.settings = get_settings()\n    self.settings.api.token = SecretStr(api_token)\n    self.settings.storage_type = storage_type\n    if storage_type == 'sqlite':\n        self.settings.sqlite = SqliteSettings(dsn=database_dsn)  # type: ignore[call-arg]\n    else:\n        self.settings.postgres = PostgresSettings(dsn=database_dsn)  # type: ignore[call-arg]\n\n    self.broker = broker\n    self.scheduler = scheduler\n\n    self._uvicorn_kwargs = {\n        'host': 'localhost',\n        'port': 8000,\n        'reload': False,\n        'workers': 1,\n        'lifespan': 'on',\n        'proxy_headers': True,\n        'forwarded_allow_ips': '*',\n        'timeout_keep_alive': 60,\n        'access_log': True,\n    }\n    self._uvicorn_kwargs.update(uvicorn_kwargs or {})\n    self._application = get_application()\n    self._application.state.broker = self.broker\n    self._application.state.scheduler = self.scheduler\n</code></pre>"},{"location":"reference/#taskiq_dashboard.TaskiqDashboard.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = get_settings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.TaskiqDashboard.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"reference/#taskiq_dashboard.TaskiqDashboard.scheduler","title":"scheduler  <code>instance-attribute</code>","text":"<pre><code>scheduler = scheduler\n</code></pre>"},{"location":"reference/#taskiq_dashboard.TaskiqDashboard.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Run the Taskiq Dashboard application using Uvicorn.</p> Source code in <code>taskiq_dashboard/interface/application.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the Taskiq Dashboard application using Uvicorn.\"\"\"\n    uvicorn.run(\n        self._application,\n        **self._uvicorn_kwargs,  # type: ignore[arg-type]\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware","title":"DashboardMiddleware","text":"<pre><code>DashboardMiddleware(\n    url,\n    api_token,\n    timeout=5.0,\n    broker_name='default_broker',\n)\n</code></pre> <p>               Bases: <code>TaskiqMiddleware</code></p> <p>A Taskiq middleware that reports task lifecycle events to an external admin dashboard API.</p> <p>This middleware sends HTTP POST requests to a configured endpoint when tasks are queued, started, or completed. It can be used for task monitoring, auditing, or visualization in external systems.</p> <p>Attributes:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Base URL of the admin API.</p> </li> <li> <code>api_token</code>               (<code>str</code>)           \u2013            <p>Token used for authenticating with the API.</p> </li> <li> <code>timeout</code>               (<code>float</code>)           \u2013            <p>Timeout (in seconds) for API requests.</p> </li> <li> <code>broker_name</code>               (<code>str</code>)           \u2013            <p>Name of the broker instance to include in the payload. Defaults to 'default_broker'.</p> </li> <li> <code>_pending</code>               (<code>set[Task]</code>)           \u2013            <p>Set of currently running background request tasks.</p> </li> <li> <code>_client</code>               (<code>AsyncClient | None</code>)           \u2013            <p>HTTP client session used for sending requests.</p> </li> </ul> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    api_token: str,\n    timeout: float = 5.0,\n    broker_name: str = 'default_broker',\n) -&gt; None:\n    super().__init__()\n    self.url = url\n    self.timeout = timeout\n    self.api_token = api_token\n    self.broker_name = broker_name\n    self._pending: set[asyncio.Task[Any]] = set()\n    self._client: httpx.AsyncClient | None = None\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = timeout\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.api_token","title":"api_token  <code>instance-attribute</code>","text":"<pre><code>api_token = api_token\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.broker_name","title":"broker_name  <code>instance-attribute</code>","text":"<pre><code>broker_name = broker_name\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>Startup method to initialize httpx.AsyncClient.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"Startup method to initialize httpx.AsyncClient.\"\"\"\n    self._client = self._get_client()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown method to run all pending requests and close the session.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown method to run all pending requests and close the session.\"\"\"\n    if self._pending:\n        await asyncio.gather(*self._pending, return_exceptions=True)\n    if self._client is not None:\n        await self._client.aclose()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.post_send","title":"post_send  <code>async</code>","text":"<pre><code>post_send(message)\n</code></pre> <p>This hook is executed right after the task is sent.</p> <p>This is a client-side hook. It executes right after the message is kicked in broker.</p> <p>:param message: kicked message.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def post_send(self, message: TaskiqMessage) -&gt; None:\n    \"\"\"\n    This hook is executed right after the task is sent.\n\n    This is a client-side hook. It executes right\n    after the message is kicked in broker.\n\n    :param message: kicked message.\n    \"\"\"\n    dict_message: dict[str, Any] = model_dump(message)\n    await self._spawn_request(\n        f'api/tasks/{message.task_id}/queued',\n        {\n            'args': dict_message['args'],\n            'kwargs': dict_message['kwargs'],\n            'labels': dict_message['labels'],\n            'queuedAt': self._now_iso(),\n            'taskName': message.task_name,\n            'worker': self.broker_name,\n        },\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.pre_execute","title":"pre_execute  <code>async</code>","text":"<pre><code>pre_execute(message)\n</code></pre> <p>This hook is called before executing task.</p> <p>This is a worker-side hook, which means it executes in the worker process.</p> <p>:param message: incoming parsed taskiq message. :return: modified message.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def pre_execute(self, message: TaskiqMessage) -&gt; TaskiqMessage:\n    \"\"\"\n    This hook is called before executing task.\n\n    This is a worker-side hook, which means it\n    executes in the worker process.\n\n    :param message: incoming parsed taskiq message.\n    :return: modified message.\n    \"\"\"\n    dict_message: dict[str, Any] = model_dump(message)\n    await self._spawn_request(\n        f'api/tasks/{message.task_id}/started',\n        {\n            'args': dict_message['args'],\n            'kwargs': dict_message['kwargs'],\n            'labels': dict_message['labels'],\n            'startedAt': self._now_iso(),\n            'taskName': message.task_name,\n            'worker': self.broker_name,\n        },\n    )\n    return message\n</code></pre>"},{"location":"reference/#taskiq_dashboard.DashboardMiddleware.post_execute","title":"post_execute  <code>async</code>","text":"<pre><code>post_execute(message, result)\n</code></pre> <p>This hook executes after task is complete.</p> <p>This is a worker-side hook. It's called in worker process.</p> <p>:param message: incoming message. :param result: result of execution for current task.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def post_execute(\n    self,\n    message: TaskiqMessage,\n    result: TaskiqResult[Any],\n) -&gt; None:\n    \"\"\"\n    This hook executes after task is complete.\n\n    This is a worker-side hook. It's called\n    in worker process.\n\n    :param message: incoming message.\n    :param result: result of execution for current task.\n    \"\"\"\n    dict_result: dict[str, Any] = model_dump(result)\n    await self._spawn_request(\n        f'api/tasks/{message.task_id}/executed',\n        {\n            'finishedAt': self._now_iso(),\n            'executionTime': result.execution_time,\n            'error': None if result.error is None else repr(result.error),\n            'returnValue': {'return_value': dict_result['return_value']},\n        },\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api","title":"api","text":""},{"location":"reference/#taskiq_dashboard.api.application","title":"application","text":""},{"location":"reference/#taskiq_dashboard.api.application.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app)\n</code></pre> Source code in <code>taskiq_dashboard/api/application.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def lifespan(app: fastapi.FastAPI) -&gt; tp.AsyncGenerator[None, None]:\n    schema_service = await app.state.dishka_container.get(AbstractSchemaService)\n    await schema_service.create_schema()\n\n    # we probably missed events about these tasks during the downtime, so we need to mark them as abandoned\n    task_repository = await app.state.dishka_container.get(AbstractTaskRepository)\n    await task_repository.batch_update(\n        old_status=TaskStatus.IN_PROGRESS,\n        new_status=TaskStatus.ABANDONED,\n    )\n    await task_repository.batch_update(\n        old_status=TaskStatus.QUEUED,\n        new_status=TaskStatus.ABANDONED,\n    )\n\n    if app.state.broker is not None:\n        await app.state.broker.startup()\n\n    if app.state.scheduler is not None:\n        for schedule_source in app.state.scheduler.sources:\n            await schedule_source.startup()\n\n    yield\n\n    if app.state.scheduler is not None:\n        for schedule_source in app.state.scheduler.sources:\n            await schedule_source.shutdown()\n\n    if app.state.broker is not None:\n        await app.state.broker.shutdown()\n\n    await app.state.dishka_container.close()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.application.get_application","title":"get_application","text":"<pre><code>get_application()\n</code></pre> Source code in <code>taskiq_dashboard/api/application.py</code> <pre><code>def get_application() -&gt; fastapi.FastAPI:\n    docs_path = '/docs'\n    app = fastapi.FastAPI(\n        title='Taskiq Dashboard',\n        summary='Taskiq administration dashboard',\n        docs_url=docs_path,\n        lifespan=lifespan,\n        exception_handlers={\n            404: exception_handler__not_found,\n        },\n    )\n    app.include_router(router=system_router)\n    app.include_router(router=task_router)\n    app.include_router(router=event_router)\n    app.include_router(router=action_router)\n    app.include_router(router=schedule_router)\n    app.mount('/static', StaticFiles(directory=pathlib.Path(__file__).parent / 'static'), name='static')\n    app.add_middleware(AccessTokenMiddleware)\n    setup_dishka(container=dependencies.container, app=app)\n    return app\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.middlewares","title":"middlewares","text":""},{"location":"reference/#taskiq_dashboard.api.middlewares.AccessTokenMiddleware","title":"AccessTokenMiddleware","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p>"},{"location":"reference/#taskiq_dashboard.api.middlewares.AccessTokenMiddleware.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(request, call_next)\n</code></pre> Source code in <code>taskiq_dashboard/api/middlewares.py</code> <pre><code>async def dispatch(self, request: Request, call_next: tp.Callable[[Request], tp.Awaitable[Response]]) -&gt; Response:\n    if not request.url.path.startswith('/api/'):\n        return await call_next(request)\n\n    token = request.headers.get('access-token')\n    if not token:\n        raise HTTPException(status_code=401, detail='Missing or invalid Authorization header')\n\n    settings = get_settings()\n    if settings.api.token.get_secret_value() != token:\n        raise HTTPException(status_code=401, detail='Invalid access token')\n    return await call_next(request)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers","title":"routers","text":""},{"location":"reference/#taskiq_dashboard.api.routers.action_router","title":"action_router  <code>module-attribute</code>","text":"<pre><code>action_router = APIRouter(\n    prefix='/actions',\n    tags=['Action'],\n    route_class=DishkaRoute,\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.event_router","title":"event_router  <code>module-attribute</code>","text":"<pre><code>event_router = APIRouter(\n    prefix='/api/tasks',\n    tags=['Event'],\n    route_class=DishkaRoute,\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule_router","title":"schedule_router  <code>module-attribute</code>","text":"<pre><code>schedule_router = APIRouter(\n    prefix='/schedules',\n    tags=['Schedule'],\n    route_class=DishkaRoute,\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.system_router","title":"system_router  <code>module-attribute</code>","text":"<pre><code>system_router = APIRouter(\n    tags=['System'], route_class=DishkaRoute\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task_router","title":"task_router  <code>module-attribute</code>","text":"<pre><code>task_router = APIRouter(\n    prefix='', tags=['Tasks'], route_class=DishkaRoute\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.action","title":"action","text":""},{"location":"reference/#taskiq_dashboard.api.routers.action.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix='/actions',\n    tags=['Action'],\n    route_class=DishkaRoute,\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.action.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.action.handle_task_run","title":"handle_task_run  <code>async</code>","text":"<pre><code>handle_task_run(request, task_name)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/action.py</code> <pre><code>@router.post(\n    '/run/{task_name}',\n    name='Kick task',\n)\nasync def handle_task_run(\n    request: fastapi.Request,\n    task_name: str,\n) -&gt; Response:\n    broker: AsyncBroker | None = request.app.state.broker\n    if broker is None:\n        logger.error('No broker configured to handle task kick', extra={'task_name': task_name})\n        return Response(status_code=status.HTTP_400_BAD_REQUEST, content=b'No broker configured')\n\n    task = broker.find_task(task_name)\n    if not task:\n        logger.error('Task not found in broker', extra={'task_name': task_name})\n        return Response(status_code=status.HTTP_404_NOT_FOUND, content=b'Task not found')\n\n    await task.kicker().with_task_id(str(uuid.uuid4())).kiq()\n\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.action.handle_task_rerun","title":"handle_task_rerun  <code>async</code>","text":"<pre><code>handle_task_rerun(request, task_id, repository)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/action.py</code> <pre><code>@router.post(\n    '/rerun/{task_id}',\n    name='Rerun task',\n)\nasync def handle_task_rerun(\n    request: fastapi.Request,\n    task_id: uuid.UUID,\n    repository: dishka_fastapi.FromDishka[AbstractTaskRepository],\n) -&gt; Response:\n    broker: AsyncBroker | None = request.app.state.broker\n    if broker is None:\n        logger.error('No broker configured to handle task kick', extra={'task_id': task_id})\n        return Response(status_code=status.HTTP_400_BAD_REQUEST, content=b'No broker configured')\n\n    existing_task = await repository.get_task_by_id(task_id)\n    if existing_task is None:\n        logger.error('Task not found in repository', extra={'task_id': str(task_id)})\n        return Response(status_code=status.HTTP_404_NOT_FOUND, content=b'Task not found')\n    task = broker.find_task(existing_task.name)\n    if not task:\n        logger.error('Task not found in broker', extra={'task_name': existing_task.name})\n        return Response(status_code=status.HTTP_404_NOT_FOUND, content=b'Task not found')\n    new_task_id = str(uuid.uuid4())\n    await (\n        task.kicker()\n        .with_task_id(new_task_id)\n        .with_labels(**existing_task.labels)\n        .kiq(\n            *existing_task.args,\n            **existing_task.kwargs,\n        )\n    )\n\n    return jinja_templates.TemplateResponse(\n        'partial/notification.html',\n        {\n            'request': request,\n            'message': (\n                f\"\"\"\n                Task rerun started with ID\n                &lt;a class=\"underline hover:ctp-text-lavander\" href=\"/tasks/{new_task_id}\"&gt;\n                    {new_task_id}.\n                &lt;/a&gt;\n                \"\"\"\n            ),\n        },\n        status_code=status.HTTP_200_OK,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.action.handle_task_delete","title":"handle_task_delete  <code>async</code>","text":"<pre><code>handle_task_delete(task_id, repository)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/action.py</code> <pre><code>@router.get(\n    '/delete/{task_id}',\n    name='Delete task',\n)\nasync def handle_task_delete(\n    task_id: uuid.UUID,\n    repository: dishka_fastapi.FromDishka[AbstractTaskRepository],\n) -&gt; Response:\n    await repository.delete_task(task_id)\n    return RedirectResponse(\n        url='/',\n        status_code=status.HTTP_307_TEMPORARY_REDIRECT,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.event","title":"event","text":""},{"location":"reference/#taskiq_dashboard.api.routers.event.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix='/api/tasks',\n    tags=['Event'],\n    route_class=DishkaRoute,\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.event.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.event.handle_task_event","title":"handle_task_event  <code>async</code>","text":"<pre><code>handle_task_event(task_id, event, task_repository, body)\n</code></pre> <p>Handle task events from TaskiqAdminMiddleware.</p> <p>This endpoint receives task events such as 'queued', 'started', and 'executed' from the TaskiqAdminMiddleware. It processes the event based on the task ID and event type.</p> <p>Parameters:</p> <ul> <li> <code>task_id</code>               (<code>UUID</code>)           \u2013            <p>The unique identifier of the task.</p> </li> <li> <code>event</code>               (<code>Literal['queued', 'started', 'executed']</code>)           \u2013            <p>The type of event (e.g., 'queued', 'started', 'executed').</p> </li> </ul> Source code in <code>taskiq_dashboard/api/routers/event.py</code> <pre><code>@router.post(\n    '/{task_id}/{event}',\n    name='Receive task event',\n)\nasync def handle_task_event(\n    task_id: uuid.UUID,\n    event: tp.Annotated[tp.Literal['queued', 'started', 'executed'], fastapi.Path(title='Event type')],\n    task_repository: dishka_fastapi.FromDishka[AbstractTaskRepository],\n    body: tp.Annotated[dict[str, tp.Any], fastapi.Body(title='Event data')],\n) -&gt; Response:\n    \"\"\"\n    Handle task events from TaskiqAdminMiddleware.\n\n    This endpoint receives task events such as 'queued', 'started', and 'executed'\n    from the TaskiqAdminMiddleware. It processes the event based on the task ID\n    and event type.\n\n    Args:\n        task_id: The unique identifier of the task.\n        event: The type of event (e.g., 'queued', 'started', 'executed').\n    \"\"\"\n    # Here you would implement the logic to handle the task event,\n    # such as updating a database record or logging the event.\n    task_arguments: QueuedTask | StartedTask | ExecutedTask\n    match event:\n        case 'queued':\n            task_arguments = QueuedTask.model_validate(body)\n            await task_repository.create_task(task_id, task_arguments)\n            logger.info('Task queued event', extra={'task_id': task_id})\n        case 'started':\n            task_arguments = StartedTask.model_validate(body)\n            await task_repository.update_task(task_id, task_arguments)\n            logger.info('Task started event', extra={'task_id': task_id})\n        case 'executed':\n            task_arguments = ExecutedTask.model_validate(body)\n            await task_repository.update_task(task_id, task_arguments)\n            logger.info('Task executed event', extra={'task_id': task_id})\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.exception_handlers","title":"exception_handlers","text":""},{"location":"reference/#taskiq_dashboard.api.routers.exception_handlers.exception_handler__not_found","title":"exception_handler__not_found  <code>async</code>","text":"<pre><code>exception_handler__not_found(request, __)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/exception_handlers.py</code> <pre><code>async def exception_handler__not_found(\n    request: fastapi.Request,\n    __: fastapi.HTTPException,\n) -&gt; HTMLResponse:\n    return jinja_templates.TemplateResponse(\n        '404.html',\n        {'request': request},\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule","title":"schedule","text":""},{"location":"reference/#taskiq_dashboard.api.routers.schedule.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix='/schedules',\n    tags=['Schedule'],\n    route_class=DishkaRoute,\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule.ScheduleFilter","title":"ScheduleFilter","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule.ScheduleFilter.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limit = 30\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule.ScheduleFilter.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offset = 0\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule.handle_schedule_list","title":"handle_schedule_list  <code>async</code>","text":"<pre><code>handle_schedule_list(request, query, hx_request=False)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/schedule.py</code> <pre><code>@router.get(\n    '/',\n    name='Schedule list view',\n    response_class=HTMLResponse,\n)\nasync def handle_schedule_list(\n    request: fastapi.Request,\n    query: tp.Annotated[ScheduleFilter, fastapi.Query(...)],\n    hx_request: tp.Annotated[bool, fastapi.Header(description='Request from htmx')] = False,  # noqa: FBT002\n) -&gt; HTMLResponse:\n    scheduler: TaskiqScheduler | None = request.app.state.scheduler\n    if not scheduler:\n        return jinja_templates.TemplateResponse(\n            name='404.html',\n            context={\n                'request': request,\n                'message': 'Scheduler not configured.',\n            },\n            status_code=status.HTTP_404_NOT_FOUND,\n        )\n    schedules = []\n    for schedule_source in sorted(scheduler.sources, key=lambda s: id(s)):\n        schedules_from_source = [schedule.model_dump() for schedule in await schedule_source.get_schedules()]\n        schedules_from_source.sort(key=lambda s: s['schedule_id'])\n        for schedule in schedules_from_source:\n            schedule['source'] = schedule_source.__class__.__name__\n            schedule['source_id'] = id(schedule_source)\n        schedules.extend(schedules_from_source)\n        if len(schedules) &gt;= query.offset + query.limit:\n            break\n\n    headers: dict[str, str] = {}\n    template_name = 'schedule_page.html'\n    if hx_request:\n        template_name = 'partial/schedule_list.html'\n        headers = {\n            'HX-Push-Url': '/schedules/?' + urlencode(query.model_dump(exclude={'limit', 'offset'})),\n        }\n\n    return jinja_templates.TemplateResponse(\n        name=template_name,\n        context={\n            'request': request,\n            'schedules': schedules[query.offset :],\n            'limit': query.limit,\n            'offset': query.offset,\n        },\n        headers=headers,\n        status_code=status.HTTP_200_OK,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.schedule.handle_schedule_details","title":"handle_schedule_details  <code>async</code>","text":"<pre><code>handle_schedule_details(request, schedule_id)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/schedule.py</code> <pre><code>@router.get(\n    '/{schedule_id}',\n    name='Schedule details view',\n    response_class=HTMLResponse,\n)\nasync def handle_schedule_details(\n    request: fastapi.Request,\n    schedule_id: str,\n) -&gt; HTMLResponse:\n    scheduler: TaskiqScheduler | None = request.app.state.scheduler\n    if not scheduler:\n        return jinja_templates.TemplateResponse(\n            name='404.html',\n            context={\n                'request': request,\n                'message': 'Scheduler not configured.',\n            },\n            status_code=status.HTTP_404_NOT_FOUND,\n        )\n    for schedule_source in scheduler.sources:\n        for schedule in await schedule_source.get_schedules():\n            if schedule.schedule_id == str(schedule_id):\n                schedule_dict = schedule.model_dump()\n                schedule_dict['source'] = schedule_source.__class__.__name__\n                schedule_dict['source_id'] = id(schedule_source)\n                return jinja_templates.TemplateResponse(\n                    name='schedule_details.html',\n                    context={\n                        'request': request,\n                        'schedule': schedule_dict,\n                    },\n                    status_code=status.HTTP_200_OK,\n                )\n    return jinja_templates.TemplateResponse(\n        name='404.html',\n        context={\n            'request': request,\n            'message': 'Schedule not found.',\n        },\n        status_code=status.HTTP_404_NOT_FOUND,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.system","title":"system","text":""},{"location":"reference/#taskiq_dashboard.api.routers.system.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(tags=['System'], route_class=DishkaRoute)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.system.HealthCheckResponse","title":"HealthCheckResponse","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/#taskiq_dashboard.api.routers.system.HealthCheckResponse.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.system.HealthCheckResponse.app_name","title":"app_name  <code>instance-attribute</code>","text":"<pre><code>app_name\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.system.get_liveness","title":"get_liveness  <code>async</code>","text":"<pre><code>get_liveness()\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/system.py</code> <pre><code>@router.get('/liveness', name='liveness', summary='\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0440\u0430\u0431\u043e\u0442\u043e\u0441\u043f\u043e\u0441\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0441\u0435\u0440\u0432\u0438\u0441\u0430')\nasync def get_liveness() -&gt; HealthCheckResponse:\n    return HealthCheckResponse(\n        status='alive',\n        app_name='taskiq dashboard',\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.system.get_readiness","title":"get_readiness  <code>async</code>","text":"<pre><code>get_readiness()\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/system.py</code> <pre><code>@router.get('/readiness', name='readiness', summary='\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0433\u043e\u0442\u043e\u0432\u043d\u043e\u0441\u0442\u0438 \u043e\u0431\u0441\u043b\u0443\u0436\u0438\u0432\u0430\u0442\u044c \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u044b')\nasync def get_readiness() -&gt; HealthCheckResponse:\n    # TODO: maybe add \"select 1\" to database\n    return HealthCheckResponse(\n        status='ready',\n        app_name='taskiq dashboard',\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task","title":"task","text":""},{"location":"reference/#taskiq_dashboard.api.routers.task.router","title":"router  <code>module-attribute</code>","text":"<pre><code>router = APIRouter(\n    prefix='', tags=['Tasks'], route_class=DishkaRoute\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter","title":"TaskFilter","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.q","title":"q  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>q = ''\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status = None\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limit = 30\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offset = 0\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.sort_by","title":"sort_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_by = 'started_at'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.sort_order","title":"sort_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_order = 'desc'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='ignore')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.validate_status","title":"validate_status  <code>classmethod</code>","text":"<pre><code>validate_status(value)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/task.py</code> <pre><code>@pydantic.field_validator('status', mode='before')\n@classmethod\ndef validate_status(\n    cls,\n    value: TaskStatus | str | None,\n) -&gt; TaskStatus | None:\n    if isinstance(value, str) and value == 'null':\n        return None\n    return value  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.TaskFilter.serialize_status","title":"serialize_status","text":"<pre><code>serialize_status(value)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/task.py</code> <pre><code>@pydantic.field_serializer('status', mode='plain')\ndef serialize_status(\n    self,\n    value: TaskStatus | None,\n) -&gt; str | None:\n    if value is None:\n        return 'null'\n    return str(value.value)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.search_tasks","title":"search_tasks  <code>async</code>","text":"<pre><code>search_tasks(request, repository, query, hx_request=False)\n</code></pre> Source code in <code>taskiq_dashboard/api/routers/task.py</code> <pre><code>@router.get(\n    '/',\n    name='Task list view',\n    response_class=HTMLResponse,\n)\nasync def search_tasks(\n    request: fastapi.Request,\n    repository: dishka_fastapi.FromDishka[AbstractTaskRepository],\n    query: tp.Annotated[TaskFilter, fastapi.Query(...)],\n    hx_request: tp.Annotated[bool, fastapi.Header(description='Request from htmx')] = False,  # noqa: FBT002\n) -&gt; HTMLResponse:\n    tasks = await repository.find_tasks(\n        name=query.q,\n        status=query.status,\n        limit=query.limit,\n        offset=query.offset,\n        sort_by=query.sort_by,\n        sort_order=query.sort_order,\n    )\n    headers: dict[str, str] = {}\n    template_name = 'home.html'\n    if hx_request:\n        headers = {\n            'HX-Push-Url': '/?' + urlencode(query.model_dump(exclude={'limit', 'offset'})),\n        }\n        template_name = 'partial/task_list.html'\n    return jinja_templates.TemplateResponse(\n        template_name,\n        {\n            'request': request,\n            'results': [task.model_dump() for task in tasks],\n            **query.model_dump(),\n        },\n        headers=headers,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.routers.task.task_details","title":"task_details  <code>async</code>","text":"<pre><code>task_details(request, repository, task_id)\n</code></pre> <p>Display detailed information for a specific task.</p> Source code in <code>taskiq_dashboard/api/routers/task.py</code> <pre><code>@router.get(\n    '/tasks/{task_id:uuid}',\n    name='Task details view',\n    response_class=HTMLResponse,\n)\nasync def task_details(\n    request: fastapi.Request,\n    repository: dishka_fastapi.FromDishka[AbstractTaskRepository],\n    task_id: uuid.UUID,\n) -&gt; HTMLResponse:\n    \"\"\"\n    Display detailed information for a specific task.\n    \"\"\"\n    task = await repository.get_task_by_id(task_id)\n    if task is None:\n        return jinja_templates.TemplateResponse(\n            name='404.html',\n            context={\n                'request': request,\n                'message': f'Task with ID {task_id} not found',\n            },\n            status_code=404,\n        )\n    result_json = None\n    if task.result:\n        result_json = json.dumps(task.result, indent=2, ensure_ascii=False)\n    return jinja_templates.TemplateResponse(\n        name='task_details.html',\n        context={\n            'request': request,\n            'task': task,\n            'task_result': result_json,\n            'enable_actions': request.app.state.broker is not None,\n            'enable_additional_actions': False,  # Placeholder for future features like retries with different args\n        },\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.api.templates","title":"templates","text":""},{"location":"reference/#taskiq_dashboard.api.templates.jinja_templates","title":"jinja_templates  <code>module-attribute</code>","text":"<pre><code>jinja_templates = Jinja2Templates(\n    directory=parent / 'templates'\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.dependencies","title":"dependencies","text":""},{"location":"reference/#taskiq_dashboard.dependencies.container","title":"container  <code>module-attribute</code>","text":"<pre><code>container = make_async_container(TaskiqDashboardProvider())\n</code></pre>"},{"location":"reference/#taskiq_dashboard.dependencies.TaskiqDashboardProvider","title":"TaskiqDashboardProvider","text":"<pre><code>TaskiqDashboardProvider(scope=APP)\n</code></pre> <p>               Bases: <code>Provider</code></p> Source code in <code>taskiq_dashboard/dependencies.py</code> <pre><code>def __init__(self, scope: Scope = Scope.APP) -&gt; None:\n    super().__init__(scope=scope)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.dependencies.TaskiqDashboardProvider.provide_settings","title":"provide_settings","text":"<pre><code>provide_settings()\n</code></pre> Source code in <code>taskiq_dashboard/dependencies.py</code> <pre><code>@provide\ndef provide_settings(self) -&gt; Settings:\n    return get_settings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.dependencies.TaskiqDashboardProvider.provide_session_provider","title":"provide_session_provider  <code>async</code>","text":"<pre><code>provide_session_provider(settings)\n</code></pre> Source code in <code>taskiq_dashboard/dependencies.py</code> <pre><code>@provide\nasync def provide_session_provider(\n    self,\n    settings: Settings,\n) -&gt; tp.AsyncGenerator[AsyncPostgresSessionProvider, tp.Any]:\n    session_provider = AsyncPostgresSessionProvider(\n        connection_settings=settings.postgres if settings.storage_type == 'postgres' else settings.sqlite,\n    )\n    yield session_provider\n    await session_provider.close()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.dependencies.TaskiqDashboardProvider.provide_task_service","title":"provide_task_service","text":"<pre><code>provide_task_service(settings, session_provider)\n</code></pre> Source code in <code>taskiq_dashboard/dependencies.py</code> <pre><code>@provide\ndef provide_task_service(\n    self,\n    settings: Settings,\n    session_provider: AsyncPostgresSessionProvider,\n) -&gt; AbstractTaskRepository:\n    return TaskRepository(\n        session_provider=session_provider,\n        task_model=PostgresTask if settings.storage_type == 'postgres' else SqliteTask,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.dependencies.TaskiqDashboardProvider.provide_schema_service","title":"provide_schema_service","text":"<pre><code>provide_schema_service(settings, session_provider)\n</code></pre> Source code in <code>taskiq_dashboard/dependencies.py</code> <pre><code>@provide\ndef provide_schema_service(\n    self,\n    settings: Settings,\n    session_provider: AsyncPostgresSessionProvider,\n) -&gt; AbstractSchemaService:\n    return SchemaService(\n        session_provider=session_provider,\n        table_name='taskiq_dashboard__tasks' if settings.storage_type == 'postgres' else 'tasks',\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure","title":"infrastructure","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.APISettings","title":"APISettings","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.APISettings.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host = '0.0.0.0'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.APISettings.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port = 8000\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.APISettings.token","title":"token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token = SecretStr('supersecret')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.APISettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(extra='allow')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings","title":"PostgresSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a PostgreSQL.</p>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.driver","title":"driver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>driver = 'postgresql+asyncpg'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host = 'localhost'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port = 5432\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user = 'taskiq-dashboard'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password = SecretStr('look_in_vault')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.database","title":"database  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>database = 'taskiq-dashboard'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.min_pool_size","title":"min_pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_pool_size = 1\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.max_pool_size","title":"max_pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_pool_size = 5\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.dsn","title":"dsn  <code>property</code>","text":"<pre><code>dsn\n</code></pre> <p>\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a PostgreSQL \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043d\u0443\u044e \u0438\u0437 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043a\u043b\u0430\u0441\u0441\u0430.</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 asyncpg:</p> <pre><code>&gt;&gt;&gt; import asyncpg\n&gt;&gt;&gt; async def create_pool(settings: PostgresSettings) -&gt; asyncpg.pool.Pool:\n&gt;&gt;&gt;     return await asyncpg.create_pool(\n&gt;&gt;&gt;            dsn=settings.postgres.dsn.get_secret_value(),\n&gt;&gt;&gt;            min_size=settings.postgres.min_size,\n&gt;&gt;&gt;            max_size=settings.postgres.max_size,\n&gt;&gt;&gt;            statement_cache_size=settings.postgres.statement_cache_size,\n&gt;&gt;&gt;     )\n</code></pre> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 SQLAlchemy:</p> <pre><code>&gt;&gt;&gt; import sqlalchemy\n&gt;&gt;&gt; async def create_pool(settings: PostgresSettings) -&gt; sqlalchemy.ext.asyncio.AsyncEngine:\n&gt;&gt;&gt;     return sqlalchemy.ext.asyncio.create_async_engine(\n&gt;&gt;&gt;         settings.postgres.dsn.get_secret_value()\n&gt;&gt;&gt;     )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.PostgresSettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(extra='ignore')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.Settings","title":"Settings","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.Settings.api","title":"api  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>api = APISettings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.Settings.storage_type","title":"storage_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage_type = 'sqlite'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.Settings.postgres","title":"postgres  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>postgres = PostgresSettings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.Settings.sqlite","title":"sqlite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqlite = SqliteSettings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.Settings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    env_nested_delimiter='__',\n    env_prefix='TASKIQ_DASHBOARD__',\n    env_file=('conf/.env', getenv('ENV_FILE', '.env')),\n    env_file_encoding='utf-8',\n    extra='ignore',\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.SqliteSettings","title":"SqliteSettings","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.SqliteSettings.driver","title":"driver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>driver = 'sqlite+aiosqlite'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.SqliteSettings.file_path","title":"file_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_path = 'taskiq_dashboard.db'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.SqliteSettings.dsn","title":"dsn  <code>property</code>","text":"<pre><code>dsn\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.SqliteSettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(extra='ignore')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.get_settings","title":"get_settings  <code>cached</code>","text":"<pre><code>get_settings()\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/settings.py</code> <pre><code>@cache\ndef get_settings() -&gt; Settings:\n    return Settings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database","title":"database","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas","title":"schemas","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.sa_metadata","title":"sa_metadata  <code>module-attribute</code>","text":"<pre><code>sa_metadata = MetaData(\n    naming_convention={\n        'ix': 'ix_%(column_0_label)s',\n        'uq': 'uq_%(table_name)s_%(column_0_name)s',\n        'ck': 'ck_%(table_name)s_%(constraint_name)s',\n        'fk': 'fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s',\n        'pk': 'pk_%(table_name)s',\n    }\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.BaseTableSchema","title":"BaseTableSchema","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask","title":"PostgresTask","text":"<p>               Bases: <code>BaseTableSchema</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id = mapped_column(\n    UUID(as_uuid=True), primary_key=True, default=uuid4\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = mapped_column(TEXT, nullable=False)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status = mapped_column(Integer, nullable=False)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.worker","title":"worker  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>worker = mapped_column(TEXT, nullable=False)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args = mapped_column(JSONB, nullable=False, default='[]')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.kwargs","title":"kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kwargs = mapped_column(JSONB, nullable=False, default='{}')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.labels","title":"labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>labels = mapped_column(JSONB, nullable=False, default='{}')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result = mapped_column(JSONB, nullable=True, default=None)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error = mapped_column(TEXT, nullable=True, default=None)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.queued_at","title":"queued_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queued_at = mapped_column(\n    DateTime(timezone=True), nullable=False, default=now\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.started_at","title":"started_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>started_at = mapped_column(\n    DateTime(timezone=True), nullable=True\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.PostgresTask.finished_at","title":"finished_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>finished_at = mapped_column(\n    DateTime(timezone=True), nullable=True\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask","title":"SqliteTask","text":"<p>               Bases: <code>BaseTableSchema</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id = mapped_column(\n    Uuid(as_uuid=True), primary_key=True, default=uuid4\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = mapped_column(TEXT, nullable=False)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status = mapped_column(INTEGER, nullable=False)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.worker","title":"worker  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>worker = mapped_column(TEXT, nullable=False)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args = mapped_column(JSON, nullable=False, default='[]')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.kwargs","title":"kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kwargs = mapped_column(JSON, nullable=False, default='{}')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.labels","title":"labels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>labels = mapped_column(JSON, nullable=False, default='{}')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result = mapped_column(JSON, nullable=True, default=None)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error = mapped_column(TEXT, nullable=True, default=None)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.queued_at","title":"queued_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queued_at = mapped_column(\n    DateTime(timezone=True), nullable=False, default=now\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.started_at","title":"started_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>started_at = mapped_column(\n    DateTime(timezone=True), nullable=True\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.schemas.SqliteTask.finished_at","title":"finished_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>finished_at = mapped_column(\n    DateTime(timezone=True), nullable=True\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.session_provider","title":"session_provider","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.database.session_provider.AsyncPostgresSessionProvider","title":"AsyncPostgresSessionProvider","text":"<pre><code>AsyncPostgresSessionProvider(connection_settings)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/database/session_provider.py</code> <pre><code>def __init__(\n    self,\n    connection_settings: PostgresSettings | SqliteSettings,\n) -&gt; None:\n    engine_parameters: dict[str, tp.Any] = {\n        'echo': False,\n    }\n\n    if isinstance(connection_settings, PostgresSettings):\n        engine_parameters.update(\n            {\n                'pool_size': connection_settings.min_pool_size,\n                'max_overflow': connection_settings.max_pool_size - connection_settings.min_pool_size,\n                'execution_options': {'prepare': False},\n                'connect_args': {  # for connection through pgbouncer\n                    'statement_cache_size': 0,\n                    'prepared_statement_cache_size': 0,\n                    'prepared_statement_name_func': lambda: f'__asyncpg_{uuid.uuid4()}__',\n                },\n            }\n        )\n\n    self._engine = sa_async.create_async_engine(\n        connection_settings.dsn.get_secret_value(),\n        **engine_parameters,\n    )\n    self._session_factory = sa_async.async_sessionmaker(\n        bind=self._engine,\n        expire_on_commit=False,\n        class_=sa_async.AsyncSession,\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.session_provider.AsyncPostgresSessionProvider.session","title":"session  <code>async</code>","text":"<pre><code>session()\n</code></pre> <p>Create and manage a new AsyncSession.</p> Usage <p>async with repository.session() as session:     # use session for database operations     result = await session.execute(...)</p> Source code in <code>taskiq_dashboard/infrastructure/database/session_provider.py</code> <pre><code>@asynccontextmanager\nasync def session(self) -&gt; tp.AsyncGenerator[sa_async.AsyncSession, None]:\n    \"\"\"\n    Create and manage a new AsyncSession.\n\n    Usage:\n        async with repository.session() as session:\n            # use session for database operations\n            result = await session.execute(...)\n    \"\"\"\n    session = self._session_factory()\n    try:\n        yield session\n        await session.commit()\n    except Exception:\n        await session.rollback()\n        raise\n    finally:\n        await session.close()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.database.session_provider.AsyncPostgresSessionProvider.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the engine and release all connections.</p> Source code in <code>taskiq_dashboard/infrastructure/database/session_provider.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the engine and release all connections.\"\"\"\n    await self._engine.dispose()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services","title":"services","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.services.schema_service","title":"schema_service","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.services.schema_service.SchemaService","title":"SchemaService","text":"<pre><code>SchemaService(\n    session_provider, table_name='taskiq_dashboard__tasks'\n)\n</code></pre> <p>               Bases: <code>AbstractSchemaService</code></p> Source code in <code>taskiq_dashboard/infrastructure/services/schema_service.py</code> <pre><code>def __init__(\n    self,\n    session_provider: AsyncPostgresSessionProvider,\n    table_name: str = 'taskiq_dashboard__tasks',\n) -&gt; None:\n    self._session_provider = session_provider\n    self._table_name = table_name\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.schema_service.SchemaService.create_schema","title":"create_schema  <code>async</code>","text":"<pre><code>create_schema()\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/schema_service.py</code> <pre><code>async def create_schema(self) -&gt; None:\n    query = f\"\"\"\n    CREATE TABLE IF NOT EXISTS {self._table_name} (\n        id UUID NOT NULL,\n        name TEXT NOT NULL,\n        status INTEGER NOT NULL,\n        worker TEXT NOT NULL,\n        args JSONB NOT NULL DEFAULT '[]',\n        kwargs JSONB NOT NULL DEFAULT '{{}}',\n        labels JSONB NOT NULL DEFAULT '{{}}',\n        result JSONB DEFAULT NULL,\n        error TEXT DEFAULT NULL,\n        queued_at TIMESTAMP WITH TIME ZONE,\n        started_at TIMESTAMP WITH TIME ZONE,\n        finished_at TIMESTAMP WITH TIME ZONE,\n        CONSTRAINT pk_{self._table_name} PRIMARY KEY (id)\n    );\n    \"\"\"\n    async with self._session_provider.session() as session:\n        await session.execute(sa.text(query))\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service","title":"task_service","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository","title":"TaskRepository","text":"<pre><code>TaskRepository(session_provider, task_model)\n</code></pre> <p>               Bases: <code>AbstractTaskRepository</code></p> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>def __init__(\n    self, session_provider: AsyncPostgresSessionProvider, task_model: type[PostgresTask] | type[SqliteTask]\n) -&gt; None:\n    self._session_provider = session_provider\n    self.task = task_model\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task = task_model\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.find_tasks","title":"find_tasks  <code>async</code>","text":"<pre><code>find_tasks(\n    name=None,\n    status=None,\n    sort_by=None,\n    sort_order='desc',\n    limit=30,\n    offset=0,\n)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>async def find_tasks(  # noqa: PLR0913\n    self,\n    name: str | None = None,\n    status: TaskStatus | None = None,\n    sort_by: tp.Literal['started_at', 'finished_at'] | None = None,\n    sort_order: tp.Literal['asc', 'desc'] = 'desc',\n    limit: int = 30,\n    offset: int = 0,\n) -&gt; list[Task]:\n    query = sa.select(self.task)\n    if name and len(name) &gt; 1:\n        search_pattern = f'%{name.strip()}%'\n        query = query.where(self.task.name.ilike(search_pattern))\n    if status is not None:\n        query = query.where(self.task.status == status.value)\n    if sort_by:\n        if sort_by == 'finished_at':\n            sort_column = self.task.finished_at\n        elif sort_by == 'started_at':\n            sort_column = self.task.started_at\n        else:\n            raise ValueError('Unsupported sort_by value: %s', sort_by)\n        query = query.order_by(sort_column.asc()) if sort_order == 'asc' else query.order_by(sort_column.desc())\n    query = query.limit(limit).offset(offset)\n    async with self._session_provider.session() as session:\n        result = await session.execute(query)\n        task_schemas = result.scalars().all()\n    return [Task.model_validate(task) for task in task_schemas]\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.get_task_by_id","title":"get_task_by_id  <code>async</code>","text":"<pre><code>get_task_by_id(task_id)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>async def get_task_by_id(self, task_id: uuid.UUID) -&gt; Task | None:\n    query = sa.select(self.task).where(self.task.id == task_id)\n    async with self._session_provider.session() as session:\n        result = await session.execute(query)\n        task = result.scalar_one_or_none()\n\n    if not task:\n        return None\n\n    return Task.model_validate(task)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.create_task","title":"create_task  <code>async</code>","text":"<pre><code>create_task(task_id, task_arguments)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>async def create_task(\n    self,\n    task_id: uuid.UUID,\n    task_arguments: QueuedTask,\n) -&gt; None:\n    query = sa.insert(self.task).values(\n        id=task_id,\n        name=task_arguments.task_name,\n        status=TaskStatus.QUEUED.value,\n        worker=task_arguments.worker or '',\n        args=task_arguments.args,\n        kwargs=task_arguments.kwargs,\n        labels=task_arguments.labels,\n        queued_at=task_arguments.queued_at,\n    )\n    async with self._session_provider.session() as session:\n        await session.execute(query)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.update_task","title":"update_task  <code>async</code>","text":"<pre><code>update_task(task_id, task_arguments)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>async def update_task(\n    self,\n    task_id: uuid.UUID,\n    task_arguments: StartedTask | ExecutedTask,\n) -&gt; None:\n    query = sa.update(self.task).where(self.task.id == task_id)\n\n    if isinstance(task_arguments, StartedTask):\n        task_status = TaskStatus.IN_PROGRESS\n        query = query.values(\n            status=task_status.value,\n            started_at=task_arguments.started_at,\n            args=task_arguments.args,\n            kwargs=task_arguments.kwargs,\n            labels=task_arguments.labels,\n            name=task_arguments.task_name,\n            worker=task_arguments.worker or '',\n        )\n    else:\n        task_status = TaskStatus.FAILURE if task_arguments.error is not None else TaskStatus.COMPLETED\n        query = query.values(\n            status=task_status.value,\n            finished_at=task_arguments.finished_at,\n            result=task_arguments.return_value.get('return_value'),\n            error=task_arguments.error,\n        )\n    async with self._session_provider.session() as session:\n        await session.execute(query)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.batch_update","title":"batch_update  <code>async</code>","text":"<pre><code>batch_update(old_status, new_status)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>async def batch_update(\n    self,\n    old_status: TaskStatus,\n    new_status: TaskStatus,\n) -&gt; None:\n    query = sa.update(self.task).where(self.task.status == old_status.value).values(status=new_status.value)\n    async with self._session_provider.session() as session:\n        await session.execute(query)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.services.task_service.TaskRepository.delete_task","title":"delete_task  <code>async</code>","text":"<pre><code>delete_task(task_id)\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/services/task_service.py</code> <pre><code>async def delete_task(\n    self,\n    task_id: uuid.UUID,\n) -&gt; None:\n    query = sa.delete(self.task).where(self.task.id == task_id)\n    async with self._session_provider.session() as session:\n        await session.execute(query)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings","title":"settings","text":""},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings","title":"PostgresSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a PostgreSQL.</p>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.driver","title":"driver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>driver = 'postgresql+asyncpg'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host = 'localhost'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port = 5432\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.user","title":"user  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user = 'taskiq-dashboard'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password = SecretStr('look_in_vault')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.database","title":"database  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>database = 'taskiq-dashboard'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.min_pool_size","title":"min_pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_pool_size = 1\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.max_pool_size","title":"max_pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_pool_size = 5\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.dsn","title":"dsn  <code>property</code>","text":"<pre><code>dsn\n</code></pre> <p>\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u0443 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a PostgreSQL \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043d\u0443\u044e \u0438\u0437 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432 \u043a\u043b\u0430\u0441\u0441\u0430.</p> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 asyncpg:</p> <pre><code>&gt;&gt;&gt; import asyncpg\n&gt;&gt;&gt; async def create_pool(settings: PostgresSettings) -&gt; asyncpg.pool.Pool:\n&gt;&gt;&gt;     return await asyncpg.create_pool(\n&gt;&gt;&gt;            dsn=settings.postgres.dsn.get_secret_value(),\n&gt;&gt;&gt;            min_size=settings.postgres.min_size,\n&gt;&gt;&gt;            max_size=settings.postgres.max_size,\n&gt;&gt;&gt;            statement_cache_size=settings.postgres.statement_cache_size,\n&gt;&gt;&gt;     )\n</code></pre> <p>\u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0441 SQLAlchemy:</p> <pre><code>&gt;&gt;&gt; import sqlalchemy\n&gt;&gt;&gt; async def create_pool(settings: PostgresSettings) -&gt; sqlalchemy.ext.asyncio.AsyncEngine:\n&gt;&gt;&gt;     return sqlalchemy.ext.asyncio.create_async_engine(\n&gt;&gt;&gt;         settings.postgres.dsn.get_secret_value()\n&gt;&gt;&gt;     )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.PostgresSettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(extra='ignore')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.SqliteSettings","title":"SqliteSettings","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.SqliteSettings.driver","title":"driver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>driver = 'sqlite+aiosqlite'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.SqliteSettings.file_path","title":"file_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_path = 'taskiq_dashboard.db'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.SqliteSettings.dsn","title":"dsn  <code>property</code>","text":"<pre><code>dsn\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.SqliteSettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(extra='ignore')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.APISettings","title":"APISettings","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.APISettings.host","title":"host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>host = '0.0.0.0'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.APISettings.port","title":"port  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port = 8000\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.APISettings.token","title":"token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token = SecretStr('supersecret')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.APISettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(extra='allow')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.Settings","title":"Settings","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.Settings.api","title":"api  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>api = APISettings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.Settings.storage_type","title":"storage_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage_type = 'sqlite'\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.Settings.postgres","title":"postgres  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>postgres = PostgresSettings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.Settings.sqlite","title":"sqlite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqlite = SqliteSettings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.Settings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    env_nested_delimiter='__',\n    env_prefix='TASKIQ_DASHBOARD__',\n    env_file=('conf/.env', getenv('ENV_FILE', '.env')),\n    env_file_encoding='utf-8',\n    extra='ignore',\n)\n</code></pre>"},{"location":"reference/#taskiq_dashboard.infrastructure.settings.get_settings","title":"get_settings  <code>cached</code>","text":"<pre><code>get_settings()\n</code></pre> Source code in <code>taskiq_dashboard/infrastructure/settings.py</code> <pre><code>@cache\ndef get_settings() -&gt; Settings:\n    return Settings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface","title":"interface","text":""},{"location":"reference/#taskiq_dashboard.interface.application","title":"application","text":""},{"location":"reference/#taskiq_dashboard.interface.application.TaskiqDashboard","title":"TaskiqDashboard","text":"<pre><code>TaskiqDashboard(\n    api_token,\n    storage_type='sqlite',\n    database_dsn='sqlite+aiosqlite:///taskiq_dashboard.db',\n    broker=None,\n    scheduler=None,\n    **uvicorn_kwargs,\n)\n</code></pre> <p>Initialize Taskiq Dashboard application.</p> <p>Parameters:</p> <ul> <li> <code>api_token</code>               (<code>str</code>)           \u2013            <p>Access token for securing the dashboard API.</p> </li> <li> <code>storage_type</code>               (<code>Literal['sqlite', 'postgres']</code>, default:                   <code>'sqlite'</code> )           \u2013            <p>Type of the storage backend ('sqlite' or 'postgres').</p> </li> <li> <code>database_dsn</code>               (<code>str</code>, default:                   <code>'sqlite+aiosqlite:///taskiq_dashboard.db'</code> )           \u2013            <p>URL for the database.</p> </li> <li> <code>broker</code>               (<code>AsyncBroker | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional Taskiq broker instance to integrate with the dashboard.</p> </li> <li> <code>scheduler</code>               (<code>TaskiqScheduler | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional Taskiq scheduler instance to integrate with the dashboard.</p> </li> <li> <code>uvicorn_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to uvicorn.</p> </li> </ul> Source code in <code>taskiq_dashboard/interface/application.py</code> <pre><code>def __init__(\n    self,\n    api_token: str,\n    storage_type: tp.Literal['sqlite', 'postgres'] = 'sqlite',\n    database_dsn: str = 'sqlite+aiosqlite:///taskiq_dashboard.db',\n    broker: AsyncBroker | None = None,\n    scheduler: TaskiqScheduler | None = None,\n    **uvicorn_kwargs: tp.Any,\n) -&gt; None:\n    \"\"\"Initialize Taskiq Dashboard application.\n\n    Args:\n        api_token: Access token for securing the dashboard API.\n        storage_type: Type of the storage backend ('sqlite' or 'postgres').\n        database_dsn: URL for the database.\n        broker: Optional Taskiq broker instance to integrate with the dashboard.\n        scheduler: Optional Taskiq scheduler instance to integrate with the dashboard.\n        uvicorn_kwargs: Additional keyword arguments to pass to uvicorn.\n    \"\"\"\n    self.settings = get_settings()\n    self.settings.api.token = SecretStr(api_token)\n    self.settings.storage_type = storage_type\n    if storage_type == 'sqlite':\n        self.settings.sqlite = SqliteSettings(dsn=database_dsn)  # type: ignore[call-arg]\n    else:\n        self.settings.postgres = PostgresSettings(dsn=database_dsn)  # type: ignore[call-arg]\n\n    self.broker = broker\n    self.scheduler = scheduler\n\n    self._uvicorn_kwargs = {\n        'host': 'localhost',\n        'port': 8000,\n        'reload': False,\n        'workers': 1,\n        'lifespan': 'on',\n        'proxy_headers': True,\n        'forwarded_allow_ips': '*',\n        'timeout_keep_alive': 60,\n        'access_log': True,\n    }\n    self._uvicorn_kwargs.update(uvicorn_kwargs or {})\n    self._application = get_application()\n    self._application.state.broker = self.broker\n    self._application.state.scheduler = self.scheduler\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.application.TaskiqDashboard.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = get_settings()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.application.TaskiqDashboard.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.application.TaskiqDashboard.scheduler","title":"scheduler  <code>instance-attribute</code>","text":"<pre><code>scheduler = scheduler\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.application.TaskiqDashboard.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Run the Taskiq Dashboard application using Uvicorn.</p> Source code in <code>taskiq_dashboard/interface/application.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the Taskiq Dashboard application using Uvicorn.\"\"\"\n    uvicorn.run(\n        self._application,\n        **self._uvicorn_kwargs,  # type: ignore[arg-type]\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware","title":"middleware","text":""},{"location":"reference/#taskiq_dashboard.interface.middleware.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger('taskiq_dashboard.admin_middleware')\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware","title":"DashboardMiddleware","text":"<pre><code>DashboardMiddleware(\n    url,\n    api_token,\n    timeout=5.0,\n    broker_name='default_broker',\n)\n</code></pre> <p>               Bases: <code>TaskiqMiddleware</code></p> <p>A Taskiq middleware that reports task lifecycle events to an external admin dashboard API.</p> <p>This middleware sends HTTP POST requests to a configured endpoint when tasks are queued, started, or completed. It can be used for task monitoring, auditing, or visualization in external systems.</p> <p>Attributes:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Base URL of the admin API.</p> </li> <li> <code>api_token</code>               (<code>str</code>)           \u2013            <p>Token used for authenticating with the API.</p> </li> <li> <code>timeout</code>               (<code>float</code>)           \u2013            <p>Timeout (in seconds) for API requests.</p> </li> <li> <code>broker_name</code>               (<code>str</code>)           \u2013            <p>Name of the broker instance to include in the payload. Defaults to 'default_broker'.</p> </li> <li> <code>_pending</code>               (<code>set[Task]</code>)           \u2013            <p>Set of currently running background request tasks.</p> </li> <li> <code>_client</code>               (<code>AsyncClient | None</code>)           \u2013            <p>HTTP client session used for sending requests.</p> </li> </ul> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    api_token: str,\n    timeout: float = 5.0,\n    broker_name: str = 'default_broker',\n) -&gt; None:\n    super().__init__()\n    self.url = url\n    self.timeout = timeout\n    self.api_token = api_token\n    self.broker_name = broker_name\n    self._pending: set[asyncio.Task[Any]] = set()\n    self._client: httpx.AsyncClient | None = None\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = timeout\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.api_token","title":"api_token  <code>instance-attribute</code>","text":"<pre><code>api_token = api_token\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.broker_name","title":"broker_name  <code>instance-attribute</code>","text":"<pre><code>broker_name = broker_name\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>Startup method to initialize httpx.AsyncClient.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"Startup method to initialize httpx.AsyncClient.\"\"\"\n    self._client = self._get_client()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown method to run all pending requests and close the session.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown method to run all pending requests and close the session.\"\"\"\n    if self._pending:\n        await asyncio.gather(*self._pending, return_exceptions=True)\n    if self._client is not None:\n        await self._client.aclose()\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.post_send","title":"post_send  <code>async</code>","text":"<pre><code>post_send(message)\n</code></pre> <p>This hook is executed right after the task is sent.</p> <p>This is a client-side hook. It executes right after the message is kicked in broker.</p> <p>:param message: kicked message.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def post_send(self, message: TaskiqMessage) -&gt; None:\n    \"\"\"\n    This hook is executed right after the task is sent.\n\n    This is a client-side hook. It executes right\n    after the message is kicked in broker.\n\n    :param message: kicked message.\n    \"\"\"\n    dict_message: dict[str, Any] = model_dump(message)\n    await self._spawn_request(\n        f'api/tasks/{message.task_id}/queued',\n        {\n            'args': dict_message['args'],\n            'kwargs': dict_message['kwargs'],\n            'labels': dict_message['labels'],\n            'queuedAt': self._now_iso(),\n            'taskName': message.task_name,\n            'worker': self.broker_name,\n        },\n    )\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.pre_execute","title":"pre_execute  <code>async</code>","text":"<pre><code>pre_execute(message)\n</code></pre> <p>This hook is called before executing task.</p> <p>This is a worker-side hook, which means it executes in the worker process.</p> <p>:param message: incoming parsed taskiq message. :return: modified message.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def pre_execute(self, message: TaskiqMessage) -&gt; TaskiqMessage:\n    \"\"\"\n    This hook is called before executing task.\n\n    This is a worker-side hook, which means it\n    executes in the worker process.\n\n    :param message: incoming parsed taskiq message.\n    :return: modified message.\n    \"\"\"\n    dict_message: dict[str, Any] = model_dump(message)\n    await self._spawn_request(\n        f'api/tasks/{message.task_id}/started',\n        {\n            'args': dict_message['args'],\n            'kwargs': dict_message['kwargs'],\n            'labels': dict_message['labels'],\n            'startedAt': self._now_iso(),\n            'taskName': message.task_name,\n            'worker': self.broker_name,\n        },\n    )\n    return message\n</code></pre>"},{"location":"reference/#taskiq_dashboard.interface.middleware.DashboardMiddleware.post_execute","title":"post_execute  <code>async</code>","text":"<pre><code>post_execute(message, result)\n</code></pre> <p>This hook executes after task is complete.</p> <p>This is a worker-side hook. It's called in worker process.</p> <p>:param message: incoming message. :param result: result of execution for current task.</p> Source code in <code>taskiq_dashboard/interface/middleware.py</code> <pre><code>async def post_execute(\n    self,\n    message: TaskiqMessage,\n    result: TaskiqResult[Any],\n) -&gt; None:\n    \"\"\"\n    This hook executes after task is complete.\n\n    This is a worker-side hook. It's called\n    in worker process.\n\n    :param message: incoming message.\n    :param result: result of execution for current task.\n    \"\"\"\n    dict_result: dict[str, Any] = model_dump(result)\n    await self._spawn_request(\n        f'api/tasks/{message.task_id}/executed',\n        {\n            'finishedAt': self._now_iso(),\n            'executionTime': result.execution_time,\n            'error': None if result.error is None else repr(result.error),\n            'returnValue': {'return_value': dict_result['return_value']},\n        },\n    )\n</code></pre>"},{"location":"tutorial/run_with_broker/","title":"Run with broker","text":"<p>You can run Taskiq Dashboard with any broker. By passing <code>broker</code> instance to the <code>TaskiqDashboard</code> constructor, you will get additional features like task actions.</p> <p></p> <p>In this example, we will demonstrate how to set up Taskiq Dashboard using a PostgreSQL broker along with a task scheduler:</p> <pre><code>import asyncio\nimport random\nimport sys\nimport typing as tp\n\nfrom taskiq_pg.asyncpg import AsyncpgBroker, AsyncpgResultBackend\n\nfrom taskiq_dashboard import DashboardMiddleware, TaskiqDashboard\n\n\ndsn = 'postgres://taskiq-dashboard:look_in_vault@localhost:5432/taskiq-dashboard'\nbroker = (\n    AsyncpgBroker(dsn)\n    .with_result_backend(AsyncpgResultBackend(dsn))\n    .with_middlewares(\n        DashboardMiddleware(\n            url='http://0.0.0.0:8000',  # the url to your taskiq-admin instance\n            api_token='supersecret',  # any secret enough string\n            broker_name='my_worker',\n        )\n    )\n)\n\n\n@broker.task(\n    task_name='task_in_example_with_broker',\n)\nasync def best_task_ever(*args, **kwargs) -&gt; dict[str, tp.Any]:\n    \"\"\"Solve all problems in the world.\"\"\"\n    await asyncio.sleep(15)\n    print('All problems are solved!')\n\n    error_probability = 0.2\n    if random.random() &lt; error_probability:\n        raise RuntimeError('An unexpected error occurred while solving problems.')\n\n    return {\n        'status': 'success',\n        'random_number': random.randint(1, 42),\n        'args': args,\n        'kwargs': kwargs,\n    }\n\n\ndef run_admin_panel() -&gt; None:\n    app = TaskiqDashboard(\n        api_token='supersecret',\n        broker=broker,\n        host='0.0.0.0',\n        port=8000,\n    )\n    app.run()\n\n\nasync def send_task() -&gt; None:\n    \"\"\"Send a task to the broker.\"\"\"\n    await broker.startup()\n    await best_task_ever.kiq('some arg', key='value')\n    await broker.shutdown()\n\n\nif __name__ == '__main__':\n    if sys.argv[1] == 'admin_panel':\n        print('Starting admin panel...')\n        run_admin_panel()\n    elif sys.argv[1] == 'send_task':\n        print('Sending task to the broker...')\n        asyncio.run(send_task())\n</code></pre> <p>To run this example, execute the following commands in different terminals:</p> <ol> <li> <p>Run the worker:</p> <pre><code>uv run taskiq worker docs.examples.example_with_broker:broker --workers 1\n</code></pre> </li> <li> <p>Run the admin panel:</p> <pre><code>uv run python -m docs.examples.example_with_broker admin_panel\n</code></pre> </li> <li> <p>Send task:</p> <pre><code>uv run python -m docs.examples.example_with_broker send_task\n</code></pre> </li> </ol> <p>After that, open your browser and navigate to <code>http://0.0.0.0:8000</code> to access the dashboard and see your task.</p>"},{"location":"tutorial/run_with_scheduler/","title":"Run with scheduler","text":"<p>You can run Taskiq Dashboard with scheduler. By passing <code>scheduler</code> instance to the <code>TaskiqDashboard</code> constructor, you will get additional page at dashboard with scheduled tasks.</p> <p></p> <p>In this example, we will demonstrate how to set up Taskiq Dashboard along with a task scheduler:</p> <pre><code>import asyncio\nimport datetime as dt\nimport random\nimport typing as tp\n\nfrom taskiq import TaskiqScheduler\nfrom taskiq_pg.asyncpg import AsyncpgBroker, AsyncpgResultBackend, AsyncpgScheduleSource\n\nfrom taskiq_dashboard import DashboardMiddleware, TaskiqDashboard\n\n\ndsn = 'postgres://taskiq-dashboard:look_in_vault@localhost:5432/taskiq-dashboard'\nbroker = (\n    AsyncpgBroker(dsn)\n    .with_result_backend(AsyncpgResultBackend(dsn))\n    .with_middlewares(\n        DashboardMiddleware(\n            url='http://0.0.0.0:8000',  # the url to your taskiq-admin instance\n            api_token='supersecret',  # any secret enough string\n            broker_name='my_worker',\n        )\n    )\n)\nscheduler = TaskiqScheduler(\n    broker=broker,\n    sources=[\n        AsyncpgScheduleSource(\n            dsn=dsn,\n            broker=broker,\n        ),\n    ],\n)\n\n\n@broker.task(\n    task_name='solve_all_problems',\n    schedule=[\n        {'cron': '*/1 * * * *'},\n        {'time': dt.datetime.now(dt.timezone.utc) + dt.timedelta(minutes=2)},\n    ],\n)\nasync def best_task_ever(*args, **kwargs) -&gt; dict[str, tp.Any]:\n    \"\"\"Solve all problems in the world.\"\"\"\n    await asyncio.sleep(15)\n    print('All problems are solved!')\n\n    error_probability = 0.2\n    if random.random() &lt; error_probability:\n        raise RuntimeError('An unexpected error occurred while solving problems.')\n\n    return {\n        'status': 'success',\n        'random_number': random.randint(1, 42),\n        'args': args,\n        'kwargs': kwargs,\n    }\n\n\ndef run_admin_panel() -&gt; None:\n    app = TaskiqDashboard(\n        api_token='supersecret',\n        broker=broker,\n        scheduler=scheduler,\n        host='0.0.0.0',\n        port=8000,\n    )\n    app.run()\n\n\nif __name__ == '__main__':\n    run_admin_panel()\n</code></pre> <p>To run this example, execute the following commands in different terminals:</p> <ol> <li> <p>Run the worker:</p> <pre><code>uv run taskiq worker docs.examples.example_with_scheduler:broker --workers 1\n</code></pre> </li> <li> <p>Run the admin panel:</p> <pre><code>uv run python -m docs.examples.example_with_scheduler\n</code></pre> </li> <li> <p>Run the scheduler (optional, only for sending task):</p> <pre><code>uv run taskiq scheduler docs.examples.example_with_scheduler:scheduler\n</code></pre> </li> </ol> <p>After that, open your browser and navigate to <code>http://0.0.0.0:8000/schedules</code> to access the dashboard and see your scheduled task.</p>"}]}